<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<meta name="renderer" content="webkit" /> <!-- 让360支持高速渲染模式 -->
<meta http-equiv="pragma" content="no-cache" /> 
<meta http-equiv="Cache-Control" content="no-store, must-revalidate" /> 
<meta http-equiv="expires" content="Wed, 26 Feb 1997 08:21:57 GMT" /> 
<meta http-equiv="expires" content="0" />
<link rel="shortcut icon" href="/favicon.ico?v=1.2" />
<link href="https://cdn.jsdelivr.net/gh/xiexuewu/xie_css_js@1.0.0/style/common.css" rel="stylesheet" />
<title>顺序查找算法（原理、实现及时间复杂度）</title>
<meta name="keywords" content="顺序,查找,算法,原理,、,实现,及,时间,复杂度," />
<meta name="description" content="一提到查找，比如从一个数列中查找第1个值为k的数，那么我们最先想到的肯定是一个一个地找。从数列的第 1 个数开始对比，直到找到值为k的数。 顺序查找 的定义为：在一个已知无序" />
</head>
<body>
<div id="header" class="clearfix">
	<a id="logo" class="left" href="/">
		<img height="26" src="/templets/default/images/logo_monkey.png" alt="数据结构和算法教程（C语言版）Logo" />
	</a>
	<ul id="nav-main" class="hover-none left clearfix">
		<li><a href="/">首页</a></li>
		<li><a href="/ds/">数据结构教程</a></li>
		<li><a href="/c/">C语言教程</a></li>
		<li><a href="/view/212.html">购买教程</a></li>
		<!--<li><a href="/c/">辅导班</a></li>-->
	</ul>
	<span id="sidebar-toggle" class="toggle-btn" toggle-target="#sidebar">目录 <span class="glyphicon"></span></span>
</div>
<!--qq交流群
<div id="header" class="clearfix">
	<ul id="nav-main" class="hover-none left clearfix">
		<li><a style="padding-left:10px" href="/uploads/allimg/240128/2-24012R01153206.jpg" target="_blank">QQ交流群：937184979</a></li>
	</ul>
</div>-->
<div id="main" class="clearfix">
	<div id="sidebar" class="toggle-target">
	<div id="contents">
		<dt><span class="glyphicon glyphicon-option-vertical" aria-hidden="true"></span>教程目录</dt>
		
			<dd>
				<span class="channel-num">1</span>
				<a href='/intro/'>数据结构概述</a>
			</dd>
		
			<dd>
				<span class="channel-num">2</span>
				<a href='/linear_list/'>线性表</a>
			</dd>
		
			<dd>
				<span class="channel-num">3</span>
				<a href='/stack_queue/'>栈和队列</a>
			</dd>
		
			<dd>
				<span class="channel-num">4</span>
				<a href='/string/'>字符串</a>
			</dd>
		
			<dd>
				<span class="channel-num">5</span>
				<a href='/array_list/'>数组和广义表</a>
			</dd>
		
			<dd>
				<span class="channel-num">6</span>
				<a href='/tree/'>树</a>
			</dd>
		
			<dd>
				<span class="channel-num">7</span>
				<a href='/graph/'>图</a>
			</dd>
		
			<dd>
				<span class="channel-num">8</span>
				<a href='/search/'>查找算法</a>
			</dd>
		
			<dd>
				<span class="channel-num">9</span>
				<a href='/sort/'>排序算法</a>
			</dd>
		
			<dd>
				<span class="channel-num">10</span>
				<a href='/out_sort/'>外部排序算法</a>
			</dd>
		
			<dd>
				<span class="channel-num">11</span>
				<a href='/memory/'>动态内存管理</a>
			</dd>
		
			<dd>
				<span class="channel-num">12</span>
				<a href='/video/'>视频教程推荐</a>
			</dd>
		
	</div>
</div>
	<div id="article-wrap">
		<div id="article">
			<div id="arc-info">
	作者：解学武
</div>
			<h1>顺序查找算法（原理、实现及时间复杂度）</h1>
			<div id="arc-body">一提到查找，比如从一个数列中查找第1个值为k的数，那么我们最先想到的肯定是一个一个地找。从数列的第 1 个数开始对比，直到找到值为k的数。<br />
<br />
<span style="color:#008000;"><u><a href='/view/351.html' target='_blank'>顺序查找</a></u></span><span style="color:#b22222;">的定义为：在一个已知无序（或有序）的<u><a href='/view/305.html' target='_blank'>队列</a></u>中找出与给定的关键字相同的数的具体位置。其原理是让关键字与队列中的数从开始一个一个地往后逐个比较，直到找到与给定的关键字相同的数。</span><br />
<br />
当然，顺序查找绝不仅限于对数字、字符的查找，也适用于前缀、对象信息的关键信息的匹配等。<br />
<h2>
	顺序查找的原理与实现</h2>
顺序查找对数列是否有序没有要求，也就是说是否有序对查找性能来说无关紧要。一般是从数列的一端开始查找，找到则返回对应的元素，没有找到则返回一个无意义的结果。<br />
<br />
算法非常简单，我们来看看代码实现：
<pre class="java">
public class SequentialSearch {
    private int[] array;
    public SequentialSearch(int[] array) {
        this.array = array;
    }
   
    /**
     * 直接顺序查找
     * @param key
     * @return
     */
    public int search(int key) {
        for (int i = 0; i &lt; array.length; i++) {
            if (array[i] == key) {
                return i;
            }
        }
        return -1;
    }
}</pre>
其实这个简单的算法也有可优化的地方，优化方法就是把k的值放在数组中下标为 0 的元素上，然后从后往前比较，直到 k 与数组中的某个值相等，这时结束；如果数组中没有与其相等的值，则也会与数组下标为 0 的值相等，这时结束。这样可以避免对于数组越界的比较。<br />
<br />
优化后的代码如下：
<pre class="java">
/**
* 哨兵方式顺序查找
* @param key
* @return
*/
public int search2(int key) {
    // 先判断是否等于下标为0的元素
    if (key == array[0]) {
        return 0;
    }
    // 临时保存array[0]的值
    int temp = array[0];
    // 赋值给下标为0的元素
    array[0] = key;
    int i = array.length - 1;
    // 倒序比较
    while(array[i] != key) {
        i --;
    }
    // 把array[0]原本的值赋回去
    array[0] = temp;
    // 比较到最后了也没有找到返回-1
    if (i == 0) {
        return -1;
    }
    // 找到了的话返回数组下标
    return i;
}</pre>
这样，循环部分的比较操作与之前相比少了一半。<br />
<h2>
	顺序查找的特点及性能分析</h2>
顺序查找没有难度和技术含量，是我们谁都能想到并且最先会想到一种最直接的方法。比如在玩扑克牌的时候，若不需要大小王，则我们会拿过来所有的牌，从头到尾地一张一张地找。<br />
<br />
当然，顺序查找也可以结合并发来处理，比如我们把待查找的数列分为前后两个部分，开启两个线程去查找，这就是利用了多核CPU去更快地完成任务。在上面扑克牌的例子中，我们如果有两个人，就会把牌的一半分给另一个人来一起找，这样显然会更快一些。<br />
<br />
在介绍查找算法的性能之前，让我们先来了解一个词 ASL（Average Search Length，平均查找长度）。需要和要查找的 key 进行比较的期望次数，被称为查找算法的平均查找长度。查找成功时的 ASL 的计算公式为 ASL=Pi&times;Ci，其中，Pi 为查找表中第 i 个元素的概率，Ci 为找到第 i 个元素时已经比较过的次数。<br />
<br />
其实我们在很多时候没必要太过纠结上面的公式，ASL 只是辅助我们了解查找性能的，其实和<u><a href='/view/vip_284.html' target='_blank'>时间复杂度</a></u>类似。针对顺序查找，在能够找到的情况下，ASL 为 1/n&times;(1+2+3+&hellip;+n)，也就是 (1+n)/2，这里假设每个元素的查找概率相等。在最坏的情况下就是没有找到，近似比较 n+2 次（在我们的优化版里需要比较 n+2 次，在普通版顺序查找里则需要比较 2n 次）。<br />
<br />
现在我们来看看顺序查找的性能，平均时间复杂度为 <code>O(n)</code>，n 是待查数列的长度，这其实没什么好解释的，因为顺序查找是从头到尾查找，而且我们可以看到查找了整个数组。当然最好的情况是数组的第 1 个元素就是我们要找的元素，这样可以直接找到，最坏的情况是到最后一个元素时才找到或者没有找到要找的元素。<br />
<br />
这里我们额外分析一种并发查找的情况，实际上我们在并发查找时查找的元素可能更多，比如两个线程把待查数列分成两部分进行查找，如果元素恰巧在第 1 个线程要查的列中，那么第 2 个线程的查找就白做了。但是通常并发还是能够更快地查找的，除了这里提到的特殊情况，元素如果在后面的线程中，则会快很多，尤其是在大数列、更多的线程时。<br />
<br />
顺序查找是对数列顺序的比较，没有额外的空间，所以<u><a href='/view/vip_284.html' target='_blank'>空间复杂度</a></u>为常数 <code>O(1)</code>。<br />
<h2>
	顺序查找的适用场景</h2>
顺序查找就是这么简单，以至于我们在一般的简单场景下根本不想用那些复杂的查找算法。<br />
<br />
我们有时需要显示一些人的详细信息，比如榜单，我们往往在排行榜中只保存了用户id与得分数，这时可以根据得分数获取前 10 名用于展示，可是我们不知道这些 id 对应哪个人，所以往往还需要用户的一些其他信息如昵称、头像等。<br />
<br />
这时我设计了这样一段代码逻辑：先找出前 10 名的 id，再查出这 10 个人的详细信息列表，然后循环这 10 个人的 id，内层循环这 10 个人的详细信息，发现 id 一致时，我们就可以找到对应的某个人的详细信息了。这里就是典型的顺序查找。<br />
<br />
顺序查找由于其简单的特点，在元素并不多的很多情况下，运用还是很广泛的。因为没有必要为了有限数量的元素使用复杂的算法。</div>
		</div>
		
	</div>
</div>
<div id="addweixin-widget" class="clearfix">
	<div class="box">
		<p>
			<a href="/uploads/allimg/240115/2-240115210631414.png" target="_blank"><img src="/uploads/allimg/240115/2-240115210631414.png" alt="添加微信咨询" title="点击查看大图"></a>
			<span class="pc-tip">添加管理员微信<br/>免费领视频教程</span>
			<span class="wap-tip">加管理员微信免费领视频教程<br>微信ID：xiexuewu333</span>
		</p>
		<span id="close-addweixin-widget" class="glyphicon glyphicon-remove-circle"></span>
	</div>
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 121;
window.arcId = "9b3faKpaYkPSauVZqYfQettla309jvcBBEF8zs+oLA5MZD7k8Jdx8F9dKQ";
window.siteId = 1;
window.cmsTempletsVer = "1.2";
</script>
<div id="footer">
	<ul id="nav-bottom" class="clearfix">
		<li><a href="/sitemap/" target="_blank">最近更新</a></li>
		<li><a href="/view/212.html" target="_blank">购买教程（带答疑）</a></li>
		<li><a href="/view/267.html" target="_blank">联系站长</a></li>
	</ul>
</div>

<script src="https://cdn.jsdelivr.net/gh/xiexuewu/xie_css_js@1.0.0/script/jquery1.12.4.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/xiexuewu/xie_css_js@1.0.0/script/jquery.snippet.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/xiexuewu/xie_css_js@1.0.0/script/common.js"></script>

<span style="display:none;"><script src="https://s22.cnzz.com/z_stat.php?id=1273514649&web_id=1273514649" language="JavaScript"></script></span>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<meta name="renderer" content="webkit" /> <!-- 让360支持高速渲染模式 -->
<meta http-equiv="pragma" content="no-cache" /> 
<meta http-equiv="Cache-Control" content="no-store, must-revalidate" /> 
<meta http-equiv="expires" content="Wed, 26 Feb 1997 08:21:57 GMT" /> 
<meta http-equiv="expires" content="0" />
<link rel="shortcut icon" href="/favicon.ico?v=1.2" />
<link href="/templets/default/style/common.css?v=1.2" rel="stylesheet" />
<title>哈夫曼树（赫夫曼树、最优树）详解</title>
<meta name="keywords" content="哈夫曼,树,赫夫,曼树,、,最优,详解,赫夫,曼树," />
<meta name="description" content="赫夫曼树，别名哈夫曼树、最优树以及最优二叉树。学习哈夫曼树之前，首先要了解几个名词。 哈夫曼树相关的几个名词 路径 ： 在一棵树中，一个结点到另一个结点之间的通路，称为" />
</head>
<body>
<div id="header" class="clearfix">
	<a id="logo" class="left" href="/">
		<img height="26" src="/templets/default/images/logo_monkey.png" alt="数据结构与算法教程Logo" />
	</a>
	<ul id="nav-main" class="hover-none left clearfix">
		<li><a href="/">教程首页</a></li>
		<li><a href="/view/212.html">购买教程（带答疑）</a></li>
	</ul>
	<span id="sidebar-toggle" class="toggle-btn" toggle-target="#sidebar">目录 <span class="glyphicon"></span></span>
</div>
<!--qq交流群-->
<div id="header" class="clearfix">
	<ul id="nav-main" class="hover-none left clearfix">
		<li><a style="padding-left:10px" href="/uploads/allimg/240128/2-24012R01153206.jpg" target="_blank">QQ交流群：937184979</a></li>
	</ul>
</div>
<div id="main" class="clearfix">
	<div id="sidebar" class="toggle-target">
	<div id="contents">
		<dt><span class="glyphicon glyphicon-option-vertical" aria-hidden="true"></span>教程目录</dt>
		
			<dd>
				<span class="channel-num">1</span>
				<a href='/intro/'>数据结构概述</a>
			</dd>
		
			<dd>
				<span class="channel-num">2</span>
				<a href='/linear_list/'>线性表</a>
			</dd>
		
			<dd>
				<span class="channel-num">3</span>
				<a href='/stack_queue/'>栈和队列</a>
			</dd>
		
			<dd>
				<span class="channel-num">4</span>
				<a href='/string/'>字符串</a>
			</dd>
		
			<dd>
				<span class="channel-num">5</span>
				<a href='/array_list/'>数组和广义表</a>
			</dd>
		<dd class="this"> <span class="channel-num">6</span> <a href="/tree/">树</a> </dd><dl class="dl-sub"><dd>6.1 <a href="/view/325.html">树存储结构是什么</a></dd><dd>6.2 <a href="/view/326.html">什么是二叉树</a></dd><dd>6.3 <a href="/view/327.html">二叉树的顺序存储结构</a></dd><dd>6.4 <a href="/view/194.html">二叉树的链式存储结构</a></dd><dd>6.5 <a href="/view/vip_237.html">浅谈二叉树的（4种）遍历算法</a><span class="glyphicon glyphicon-usd"></span></dd><dd>6.6 <a href="/view/328.html">二叉树的先序遍历算法（递归和非递归）</a></dd><dd>6.7 <a href="/view/329.html">二叉树的中序遍历算法（递归和非递归）</a></dd><dd>6.8 <a href="/view/330.html">二叉树的后序遍历算法（递归和非递归）</a></dd><dd>6.9 <a href="/view/331.html">二叉树的层次遍历</a></dd><dd>6.10 <a href="/view/vip_265.html">线索二叉树：遍历效率更高的二叉树</a><span class="glyphicon glyphicon-usd"></span></dd><dd>6.11 <a href="/view/vip_266.html">双向线索二叉树：更高级的线索二叉树</a><span class="glyphicon glyphicon-usd"></span></dd><dd>6.12 <a href="/view/332.html">树的双亲表示法</a></dd><dd>6.13 <a href="/view/197.html">树的孩子表示法</a></dd><dd>6.14 <a href="/view/198.html">树的孩子兄弟表示法</a></dd><dd>6.15 <a href="/view/vip_241.html">孩子兄弟表示法将森林转变成二叉树</a><span class="glyphicon glyphicon-usd"></span></dd><dd>6.16 <a href="/view/333.html">哈夫曼树（赫夫曼树、最优树）详解</a></dd><dd>6.17 <a href="/view/vip_334.html">哈夫曼编码（C语言实现）</a><span class="glyphicon glyphicon-usd"></span></dd><dd>6.18 <a href="/view/335.html">回溯算法详解</a></dd><dd>6.19 <a href="/view/vip_336.html">回溯算法解决八皇后问题</a><span class="glyphicon glyphicon-usd"></span></dd><dd>6.20 <a href="/view/vip_242.html">回溯算法实现移动迷宫小游戏(初级版)</a><span class="glyphicon glyphicon-usd"></span></dd><dd>6.21 <a href="/view/vip_337.html">n个结点最多可以构建多少棵树？</a><span class="glyphicon glyphicon-usd"></span></dd></dl>
			<dd>
				<span class="channel-num">7</span>
				<a href='/graph/'>图</a>
			</dd>
		
			<dd>
				<span class="channel-num">8</span>
				<a href='/search/'>查找算法</a>
			</dd>
		
			<dd>
				<span class="channel-num">9</span>
				<a href='/sort/'>排序算法</a>
			</dd>
		
			<dd>
				<span class="channel-num">10</span>
				<a href='/out_sort/'>外部排序算法</a>
			</dd>
		
			<dd>
				<span class="channel-num">11</span>
				<a href='/memory/'>动态内存管理</a>
			</dd>
		
			<dd>
				<span class="channel-num">12</span>
				<a href='/video/'>数据结构与算法视频教程</a>
			</dd>
		
	</div>
</div>
	<div id="article-wrap">
		<div id="article">
			<div id="arc-info">
	作者：解学武
</div>
			<h1>哈夫曼树（赫夫曼树、最优树）详解</h1>
			<div class="pre-next-page pre-next-detail clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="/view/vip_241.html">孩子兄弟表示法将森林转变成二叉树</a></span>
                    <span class="next right"><a href="/view/vip_334.html">哈夫曼编码（C语言实现）</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <div class="pre-next-page pre-next-brief clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="#">上一节</a></span>
                    <span class="next right"><a href="#">下一节</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <script type="text/javascript">window.prePageURL = "/view/vip_241.html";window.nextPageURL = "/view/vip_334.html";</script>
			<div id="arc-body">赫夫曼<u><a href='/view/23.html' target='_blank'>树</a></u>，别名&ldquo;<u><a href='/view/33.html' target='_blank'>哈夫曼树</a></u>&rdquo;、&ldquo;最优树&rdquo;以及&ldquo;最优<u><a href='/view/192.html' target='_blank'>二叉树</a></u>&rdquo;。学习哈夫曼树之前，首先要了解几个名词。
<h2>
	哈夫曼树相关的几个名词</h2>
<span style="color: rgb(0, 128, 0);">路径</span>：<span style="color: rgb(178, 34, 34);">在一棵树中，一个结点到另一个结点之间的通路，称为</span><span style="color: rgb(0, 128, 0);">路径</span>。<u><a href='/view/200.html' target='_blank'>图</a></u> 1 中，从根结点到结点 a 之间的通路就是一条路径。<br />
<br />
<span style="color: rgb(0, 128, 0);">路径长度</span>：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。<br />
<br />
<span style="color: rgb(0, 128, 0);">结点的权</span>：<span style="color: rgb(178, 34, 34);">给每一个结点赋予一个新的数值，被称为这个结点的权</span>。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。<br />
<br />
<span style="color: rgb(0, 128, 0);">结点的带权路径长度</span>：<span style="color: rgb(178, 34, 34);">指的是从根结点到该结点之间的路径长度与该结点的权的乘积</span>。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。<br />
<br />
树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作<span style="color: rgb(0, 128, 0);">&nbsp;&ldquo;WPL&rdquo;</span>&nbsp;。例如图 1 中所示的这颗树的带权路径长度为：
<blockquote>
	<p>
		WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3</p>
</blockquote>
<div style="text-align: center;">
	<img alt="" src="/uploads/allimg/240114/141K95034-0.png" style="width: 185px; height: 217px;" /><br />
	图1 哈夫曼树</div>
<h2>
	什么是哈夫曼树</h2>
<span style="color: rgb(178, 34, 34);">当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为&ldquo;最优二叉树&rdquo;，有时也叫&ldquo;赫夫曼树&rdquo;或者&ldquo;哈夫曼树&rdquo;。</span><br />
<br />
在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。
<h2>
	构建哈夫曼树的过程</h2>
对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：<br />
<ol>
	<li>
		在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li>
	<li>
		在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到&nbsp;n&ndash;2 个权值的行列中，以此类推；</li>
	<li>
		重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li>
</ol>
<div style="text-align: center;">
	<img alt="" src="/uploads/allimg/240114/141K9BH-1.png" style="width: 427px; height: 433px;" /></div>
<div style="text-align: center;">
	图 2 哈夫曼树的构建过程<br />
	&nbsp;</div>
图 2 中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。
<h2>
	哈弗曼树中结点结构</h2>
构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。<br />
<br />
所以，哈夫曼树中结点构成用代码表示为：
<pre class="cpp">
//哈夫曼树结点结构
typedef struct {
    int weight;//结点权重
    int parent, left, right;//父结点、左孩子、右孩子在<u><a href='/view/181.html' target='_blank'>数组</a></u>中的位置下标
}HTNode, *HuffmanTree;</pre>
<h2>
	构建哈弗曼树的算法实现</h2>
构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。<br />
<br />
查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：<br />
<ul>
	<li>
		如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；</li>
	<li>
		如果介于两个结点权重值之间，替换原来较大的结点；</li>
</ul>
<br />
实现代码：
<pre class="cpp">
//HT数组中存放的哈夫曼树，end表示HT数组中存放结点的最终位置，s1和s2传递的是HT数组中权重值最小的两个结点在数组中的位置
void Select(HuffmanTree HT, int end, int* s1, int* s2)
{
    int min1, min2;
    int i = 1, j;
    //找到还没构建树的结点
    while (HT[i].parent != 0 &amp;&amp; i &lt;= end) {
        i++;
    }
    min1 = HT[i].weight;
    *s1 = i;

    i++;
    while (HT[i].parent != 0 &amp;&amp; i &lt;= end) {
        i++;
    }
    //对找到的两个结点比较大小，min2为大的，min1为小的
    if (HT[i].weight &lt; min1) {
        min2 = min1;
        *s2 = *s1;
        min1 = HT[i].weight;
        *s1 = i;
    }
    else {
        min2 = HT[i].weight;
        *s2 = i;
    }
    //两个结点和后续的所有未构建成树的结点做比较
    for (j = i + 1; j &lt;= end; j++)
    {
        //如果有父结点，直接跳过，进行下一个
        if (HT[j].parent != 0) {
            continue;
        }
        //如果比最小的还小，将min2=min1，min1赋值新的结点的下标
        if (HT[j].weight &lt; min1) {
            min2 = min1;
            min1 = HT[j].weight;
            *s2 = *s1;
            *s1 = j;
        }
        //如果介于两者之间，min2赋值为新的结点的位置下标
        else if (HT[j].weight &gt;= min1 &amp;&amp; HT[j].weight &lt; min2) {
            min2 = HT[j].weight;
            *s2 = j;
        }
    }
}</pre>
<blockquote>
	<p>
		<span style="color: rgb(178, 34, 34);">注意</span>：s1和s2传入的是实参的地址，所以函数运行完成后，实参中存放的自然就是哈夫曼树中权重值最小的两个结点在数组中的位置。</p>
</blockquote>
构建哈弗曼树的代码实现如下：
<pre class="cpp">
//HT为地址传递的存储哈夫曼树的数组，w为存储结点权重值的数组，n为结点个数
void CreateHuffmanTree(HuffmanTree* HT, int* w, int n)
{
    int m, i;
    if (n &lt;= 1) return; // 如果只有一个编码就相当于0
    m = 2 * n - 1; // 哈夫曼树总节点数，n就是叶子结点
    *HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode)); // 0号位置不用
    HuffmanTree p = *HT;
    // 初始化哈夫曼树中的所有结点
    for (i = 1; i &lt;= n; i++)
    {
        (p + i)-&gt;weight = *(w + i - 1);
        (p + i)-&gt;parent = 0;
        (p + i)-&gt;left = 0;
        (p + i)-&gt;right = 0;
    }
    //从树组的下标 n+1 开始初始化哈夫曼树中除叶子结点外的结点
    for (i = n + 1; i &lt;= m; i++)
    {
        (p + i)-&gt;weight = 0;
        (p + i)-&gt;parent = 0;
        (p + i)-&gt;left = 0;
        (p + i)-&gt;right = 0;
    }
    //构建哈夫曼树
    for (i = n + 1; i &lt;= m; i++)
    {
        int s1, s2;
        Select(*HT, i - 1, &amp;s1, &amp;s2);
        (*HT)[s1].parent = (*HT)[s2].parent = i;
        (*HT)[i].left = s1;
        (*HT)[i].right = s2;
        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;
    }
}</pre>
注意，如果使用此程序，对权重值分别为 2、8、7、6、5 的节点构建哈夫曼树，最终效果如图 4(A) 所示。但其实，图 4(B) 中显示的哈夫曼树也满足条件，这两棵树的带权路径长度相同。<br />
<br />
<div style="text-align: center;">
	<img alt="" src="/uploads/allimg/240114/141K91317-2.png" style="width: 551px; height: 328px;" /><br />
	图 4 两种哈夫曼树</div>
<br />
之所以使用此程序构建的哈夫曼树，是图 4(A) 而不是 4(B)，是因为在构建哈夫曼树时，结点 2 和结点 5 构建的新的结点 7 存储在动态树组中位置，比权重值为 7 节点的存储位置还靠后，所以，在程序继续选择两个权值最小的结点时，直接选择了的叶子结点 6 和 7 。<br />
<br />
构建哈夫曼树，通常就是为了得到各个元素对应的哈夫曼编码，从而实现数据的压缩存储。有关哈夫曼编码，请猛击阅读《<a href="/view/vip_334.html" target="_blank">哈夫曼编码</a>》一文。</div>
			<div class="pre-next-page pre-next-detail clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="/view/vip_241.html">孩子兄弟表示法将森林转变成二叉树</a></span>
                    <span class="next right"><a href="/view/vip_334.html">哈夫曼编码（C语言实现）</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <div class="pre-next-page pre-next-brief clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="#">上一节</a></span>
                    <span class="next right"><a href="#">下一节</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <script type="text/javascript">window.prePageURL = "/view/vip_241.html";window.nextPageURL = "/view/vip_334.html";</script>
		</div>
		
	</div>
</div>
<div id="addweixin-widget" class="clearfix">
	<div class="box">
		<p>
			<a href="/uploads/allimg/240115/2-240115210631414.png" target="_blank"><img src="/uploads/allimg/240115/2-240115210631414.png" alt="添加微信咨询" title="点击查看大图"></a>
			<span class="pc-tip">扫码添加管理员微信</span>
			<span class="wap-tip">扫码添加管理员微信<br>微信ID：x15297649174</span>
		</p>
		<span id="close-addweixin-widget" class="glyphicon glyphicon-remove-circle"></span>
	</div>
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 333;
window.arcId = "bd7d/nCb3vV7zw98d4Ukkj6ECyZCv3LREEm8vo7s0XSadMCgz93ziqVvNw";
window.siteId = 1;
window.cmsTempletsVer = "1.2";
</script>
<div id="footer">
	<ul id="nav-bottom" class="clearfix">
		<li><a href="/view/267.html" target="_blank">联系方式</a></li>
		<li><a href="/view/212.html" target="_blank">购买教程（带答疑）</a></li>
	</ul>
</div>

<script src="/templets/default/script/jquery1.12.4.min.js"></script>
<script src="/templets/default/script/jquery.snippet.js"></script>
<script src="/templets/default/script/common.js?v=1.2"></script>

<span style="display:none;"><script src="https://s22.cnzz.com/z_stat.php?id=1273514649&web_id=1273514649" language="JavaScript"></script></span>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<meta name="renderer" content="webkit" /> <!-- 让360支持高速渲染模式 -->
<meta http-equiv="pragma" content="no-cache" /> 
<meta http-equiv="Cache-Control" content="no-store, must-revalidate" /> 
<meta http-equiv="expires" content="Wed, 26 Feb 1997 08:21:57 GMT" /> 
<meta http-equiv="expires" content="0" />
<link rel="shortcut icon" href="/favicon.ico?v=1.2" />
<link href="/templets/default/style/common.css?v=1.2" rel="stylesheet" />
<title>分页机制究竟是如何实现的？</title>
<meta name="keywords" content="分页,机制,究,竟是,如何,实现,的,现代," />
<meta name="description" content="现代操作系统都使用分页机制来管理内存，这使得每个程序都拥有自己的地址空间。每当程序使用虚拟地址进行读写时，都必须转换为实际的物理地址，才能真正在内存条上定位数据。" />
</head>
<body>
<div id="header" class="clearfix">
	<a id="logo" class="left" href="/">
		<img height="26" src="/templets/default/images/logo_monkey.png" alt="数据结构与算法教程Logo" />
	</a>
	<ul id="nav-main" class="hover-none left clearfix">
		<li><a href="/">教程首页</a></li>
		<li><a href="/view/212.html">购买教程</a></li>
		<!--<li><a href="/c/">辅导班</a></li>-->
	</ul>
	<span id="sidebar-toggle" class="toggle-btn" toggle-target="#sidebar">目录 <span class="glyphicon"></span></span>
</div>
<!--qq交流群
<div id="header" class="clearfix">
	<ul id="nav-main" class="hover-none left clearfix">
		<li><a style="padding-left:10px" href="/uploads/allimg/240128/2-24012R01153206.jpg" target="_blank">QQ交流群：937184979</a></li>
	</ul>
</div>-->
<div id="main" class="clearfix">
	<div id="sidebar" class="toggle-target">
	<div id="contents">
		<dt><span class="glyphicon glyphicon-option-vertical" aria-hidden="true"></span>教程目录</dt>
		
			<dd>
				<span class="channel-num">1</span>
				<a href='/c/base/'>编程基础</a>
			</dd>
		
			<dd>
				<span class="channel-num">2</span>
				<a href='/c/begin/'>C语言初探</a>
			</dd>
		
			<dd>
				<span class="channel-num">3</span>
				<a href='/c/variable_datatype/'>变量和数据类型</a>
			</dd>
		
			<dd>
				<span class="channel-num">4</span>
				<a href='/c/io/'>C语言输入输出</a>
			</dd>
		
			<dd>
				<span class="channel-num">5</span>
				<a href='/c/branch_loop/'>循环结构和选择结构</a>
			</dd>
		
			<dd>
				<span class="channel-num">6</span>
				<a href='/c/array/'>C语言数组</a>
			</dd>
		
			<dd>
				<span class="channel-num">7</span>
				<a href='/c/function/'>C语言函数</a>
			</dd>
		
			<dd>
				<span class="channel-num">8</span>
				<a href='/c/preprocess/'>预处理命令</a>
			</dd>
		
			<dd>
				<span class="channel-num">9</span>
				<a href='/c/pointer/'>指针</a>
			</dd>
		
			<dd>
				<span class="channel-num">10</span>
				<a href='/c/struct/'>结构体</a>
			</dd>
		
			<dd>
				<span class="channel-num">11</span>
				<a href='/c/file/'>文件操作</a>
			</dd>
		
			<dd>
				<span class="channel-num">12</span>
				<a href='/c/debug/'>C语言调试</a>
			</dd>
		<dd class="this"> <span class="channel-num">13</span> <a href="/c/memory/">C语言内存精讲</a> </dd><dl class="dl-sub"><dd>13.1 <a href="/view/566.html">一个程序在计算机中到底是如何运行的？</a></dd><dd>13.2 <a href="/view/567.html">虚拟内存到底是什么？为什么我们在C语言中看到的地址是假的？</a></dd><dd>13.3 <a href="/view/568.html">虚拟地址空间以及编译模式</a></dd><dd>13.4 <a href="/view/569.html">C语言内存对齐，提高寻址效率</a></dd><dd>13.5 <a href="/view/570.html">内存分页机制，完成虚拟地址的映射</a></dd><dd>13.6 <a href="/view/571.html">分页机制究竟是如何实现的？</a></dd><dd>13.7 <a href="/view/572.html">MMU部件以及对内存权限的控制</a></dd><dd>13.8 <a href="/view/573.html">Linux下C语言程序的内存布局</a></dd><dd>13.9 <a href="/view/574.html">Windows下C语言程序的内存布局</a></dd><dd>13.10 <a href="/view/575.html">用户模式和内核模式</a></dd><dd>13.11 <a href="/view/576.html">栈（Stack）是什么？栈溢出又是怎么回事？</a></dd><dd>13.12 <a href="/view/577.html">一个函数在栈上到底是怎样的？</a></dd><dd>13.13 <a href="/view/578.html">函数调用惯例(Calling Convention)</a></dd><dd>13.14 <a href="/view/579.html">用一个实例来深入剖析函数进栈出栈的过程</a></dd><dd>13.15 <a href="/view/580.html">栈溢出攻击的原理是什么？</a></dd><dd>13.16 <a href="/view/581.html">C语言动态内存分配</a></dd><dd>13.17 <a href="/view/582.html">malloc函数背后的实现原理——内存池</a></dd><dd>13.18 <a href="/view/583.html">C语言野指针以及非法内存操作</a></dd><dd>13.19 <a href="/view/584.html">C语言内存泄露（内存丢失）</a></dd><dd>13.20 <a href="/view/585.html">C语言变量的存储类别和生存期</a></dd></dl>
			<dd>
				<span class="channel-num">14</span>
				<a href='/c/module/'>多文件编程</a>
			</dd>
		
			<dd>
				<span class="channel-num">15</span>
				<a href='/c/practice/'>C语言项目实战案例</a>
			</dd>
		
	</div>
</div>
	<div id="article-wrap">
		<div id="article">
			<h1>分页机制究竟是如何实现的？</h1>
			<div class="pre-next-page pre-next-detail clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="/view/570.html">内存分页机制，完成虚拟地址的映射</a></span>
                    <span class="next right"><a href="/view/572.html">MMU部件以及对内存权限的控制</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <div class="pre-next-page pre-next-brief clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="#">上一节</a></span>
                    <span class="next right"><a href="#">下一节</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <script type="text/javascript">window.prePageURL = "/view/570.html";window.nextPageURL = "/view/572.html";</script>
			<div id="arc-body">现代操作系统都使用分页机制来管理内存，这使得每个程序都拥有自己的地址空间。每当程序使用虚拟地址进行读写时，都必须转换为实际的物理地址，才能真正在内存条上定位数据。如下图所示：<br />
<br />
<div style="text-align: center">
	<img alt="" src="/uploads/allimg/240821/2051233544-0.jpg" style="height: 202px; width: 180px" /></div>
<br />
内存地址的转换是通过一种叫做<span style="color: #008000">页表（Page Table）</span>的机制来完成的，这是本节要讲解的重点，即：
<ul>
	<li>
		页表是什么？为什么要采用页表机制，而不采用其他机制？</li>
	<li>
		虚拟地址如何通过页表转换为物理地址？</li>
</ul>
<h2>
	直接使用<u><a href='/view/181.html' target='_blank'>数组</a></u>转换</h2>
最容易想到的映射方案是使用数组：每个数组元素保存一个物理地址，而把虚拟地址作为数组下标，这样就能够很容易地完成映射，并且效率不低。如下图所示：<br />
<br />
<div style="text-align: center">
	<img alt="" src="/uploads/allimg/240821/2051235056-1.jpg" style="height: 236px; width: 626px" /></div>
<br />
但是这样的数组有 2^32 个元素，每个元素大小为 4 个字节，总共占用 16GB 的内存，显现是不现实的！
<h2>
	使用一级页表</h2>
既然内存是分页的，只要我们能够定位到数据所在的页，以及它在页内的偏移（也就是距离页开头的字节数），就能够转换为物理地址。例如，一个 int 类型的值保存在第 12 页，页内偏移为 240，那么对应的物理地址就是 2^12 * 12 + 240 =&nbsp;49392。
<blockquote>
	2^12 为一个页的大小，也就是4K。</blockquote>
虚拟地址空间大小为 4GB，总共包含 2^32 / 2^12 = 2^20 = 1K * 1K &nbsp;= 1M =&nbsp;1048576 个页面，我们可以定义一个这样的数组：它包含 2^20 = 1M 个元素，每个元素的值为页面编号（也就是位于第几个页面），长度为 4 字节，整个数组共占用 4MB 的内存空间。这样的数组就称为<span style="color: #008000">页表（Page Table）</span>，它记录了地址空间中所有页的编号。<br />
<br />
虚拟地址长度为 32 位，我们不妨进行一下切割，将高 20 位作为页表数组的下标，低 12 位作为页内偏移。如下图所示：<br />
<br />
<div style="text-align: center">
	<img alt="" src="/uploads/allimg/240821/20512344F-2.jpg" style="height: 52px; width: 300px" /></div>
<br />
为什么要这样切割呢？因为页表数组共有 2^20 = 1M 个元素，使用虚拟地址的高 20 位作为下标，正好能够访问数组中的所有元素；并且，一个页面的大小为 2^12 = 4KB，使用虚拟地址的低 12 位恰好能够表示所有偏移。<br />
<br />
注意，表示页面编号只需要 20 位，而页表数组的每个元素的长度却为 4 字节，即 32 位，多出 32 - 20 = 12 位。这 12 位也有很大的用处，可以用来表示当前页的相关属性，例如是否有读写权限、是否已经分配物理内存、是否被换出到硬盘等。<br />
<br />
例如一个虚拟地址 0XA010BA01，它的高 20 位是 0XA010B，所以需要访问页表数组的第&nbsp;0XA010B 个元素，才能找到数据所在的物理页面。假设页表数组第&nbsp;0XA010B 个元素的值为 0X0F70AAA0，它的高 20 位为 0X0F70A，那么就可以确定<span style="color: #b22222">数据位于第 0X0F70A 个物理页面</span>。再来看虚拟地址，它的低 12 位是 0XA01，所以<span style="color: #b22222">页内偏移也是 0XA01</span>。有了页面索引和页内偏移，就可以算出物理地址了。经过计算，最终的物理地址为 0X0F70A * 2^12 + 0XA01 = 0X0F70A000 + 0XA01 = 0X0F70AA01。<br />
<br />
这种思路所形成的映射关系如下图所示：<br />
<br />
<div style="text-align: center">
	<img alt="" src="/uploads/allimg/240821/2051233447-3.jpg" style="height: 292px; width: 681px" /></div>
<br />
可以发现，有的页被映射到物理内存，有的被映射到硬盘，不同的映射方式可以由页表数组元素的低 12 位来控制。<br />
<br />
使用这种方案，不管程序占用多大的内存，都要为页表数组分配 4M 的内存空间（页表数组也必须放在物理内存中），因为虚拟地址空间中的高 1G 或 2G 是被系统占用的，必须保证较大的数组下标有效。<br />
<br />
现在硬件很便宜了，内存容量大了，很多电脑都配备 4G 或 8G 的内存，页表数组占用 4M 内存或许不觉得多，但在 32 位系统刚刚发布的时候，内存还是很紧缺的资源，很多电脑才配备 100M 甚至几十兆的内存，4M 内存就显得有点大了，所以还得对上面的方案进行改进，压缩页表数组所占用的内存。
<h2>
	使用两级页表</h2>
上面的页表共有 2^20 = 2^10 * 2^10 个元素，为了压缩页表的存储空间，可以将上面的页表分拆成 2^10 = 1K = 1024 个小的页表，这样每个页表只包含 2^10 = 1K = 1024 个元素，占用 2^10 * 4 = 4KB 的内存，也即一个页面的大小。这 1024 个小的页表，可以存储在不同的物理页，它们之间可以是不连续的。<br />
<br />
那么问题来了，既然这些小的页表分散存储，位于不同的物理页，该如何定位它们呢？也就是如何记录它们的编号（也即在物理内存中位于第几个页面）。<br />
<br />
1024 个页表有 1024 个索引，所以不能用一个指针指向它们，必须将这些索引再保存到一个额外的数组中。这个额外的数组有 1024 个元素，每个元素记录一个页表所在物理页的编号，长度为 4 个字节，总共占用 4KB 的内存。我们将这个额外的数组称为<span style="color: #008000">页目录（Page Directory）</span>，因为它的每一个元素对应一个页表。<br />
<br />
如此，只要使用一个指针来记住页目录的地址即可，等到进行地址转换时，可以根据这个指针找到页目录，再根据页目录找到页表，最后找到物理地址，前后共经过3次间接转换。<br />
<br />
那么，如何根据虚拟地址找到页目录和页表中相应的元素呢？我们不妨将虚拟地址分割为三分部，高 10 位作为页目录中元素的下标，中间 10 位作为页表中元素的下标，最后 12 位作为页内偏移，如下图所示：<br />
<br />
<div style="text-align: center">
	<img alt="" src="/uploads/allimg/240821/2051232X4-4.jpg" style="height: 52px; width: 300px" /></div>
<br />
前面我们说过，知道了物理页的索引和页内偏移就可以转换为物理地址了，在这种方案中，页内偏移可以从虚拟地址的低 12 位得到，但是物理页索引却保存在 1024 个分散的小页表中，所以就必须先根据页目录找到对应的页表，再根据页表找到物理页索引。<br />
<br />
例如一个虚拟地址 0011000101 &nbsp;1010001100 &nbsp;<span style="color: #008000">111100001010</span>，它的高 10 位为&nbsp;0011000101，对应页目录中的第&nbsp;0011000101 个元素，假设该元素的高20位为 0XF012A，也即对应的页表在物理内存中的编号为&nbsp;0XF012A，这样就找到了页表。虚拟地址中间 10 位为&nbsp;1010001100，它对应页表中的第&nbsp;1010001100 个元素，假设该元素的高 20 位为 0X00D20，也即物理页的索引为 <span style="color: #b22222">0X00D20</span>。通过计算，最终的物理地址为&nbsp;<span style="color: rgb(178,34,34)">0X00D20</span>&nbsp;* 2^12 +&nbsp;<span style="color: rgb(0,128,0)">111100001010</span>&nbsp;= 0X00D20F0A。<br />
<br />
这种思路所形成的映射关系如下图所示：<br />
<br />
<div style="text-align: center">
	<img alt="" src="/uploads/allimg/240821/20512353T-5.jpg" style="height: 528px; width: 699px" /></div>
<blockquote>
	图中的点状虚线说明了最终的映射关系。图中没有考虑映射到硬盘的情况。</blockquote>
<br />
采用这样的两级页表的一个明显优点是，如果程序占用的内存较少，分散的小页表的个数就会远远少于 1024 个，只会占用很少的一部分存储空间（远远小于4M）。<br />
<br />
在极少数的情况下，程序占用的内存非常大，布满了 4G 的虚拟地址空间，这样小页表的数量可能接近甚至等于 1024，再加上页目录占用的存储空间，总共是 4MB+4KB，比上面使用一级页表的方案仅仅多出 4KB 的内存。这是可以容忍的，因为很少出现如此极端的情况。<br />
<br />
也就是说，使用两级页表后，页表占用的内存空间不固定，它和程序本身占用的内存空间成正比，从整体上来看，会比使用一级页表占用的内存少得多。
<h2>
	使用多级页表</h2>
对于64位环境，虚拟地址空间达到 256TB，使用二级页表占用的存储空间依然不小，所以会更加细化，从而使用三级页表甚至多级页表，这样就会有多个页目录，虚拟地址也会被分割成多个部分，思路和上面是一样的，不再赘述。<br />
</div>
			<div class="pre-next-page pre-next-detail clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="/view/570.html">内存分页机制，完成虚拟地址的映射</a></span>
                    <span class="next right"><a href="/view/572.html">MMU部件以及对内存权限的控制</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <div class="pre-next-page pre-next-brief clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="#">上一节</a></span>
                    <span class="next right"><a href="#">下一节</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <script type="text/javascript">window.prePageURL = "/view/570.html";window.nextPageURL = "/view/572.html";</script>
		</div>
		
	</div>
</div>
<div id="addweixin-widget" class="clearfix">
	<div class="box">
		<p>
			<a href="/uploads/allimg/240115/2-240115210631414.png" target="_blank"><img src="/uploads/allimg/240115/2-240115210631414.png" alt="添加微信咨询" title="点击查看大图"></a>
			<span class="pc-tip">添加管理员微信<br/>免费领视频教程</span>
			<span class="wap-tip">加管理员微信免费领视频教程<br>微信ID：xiexuewu333</span>
		</p>
		<span id="close-addweixin-widget" class="glyphicon glyphicon-remove-circle"></span>
	</div>
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 571;
window.arcId = "7a7euVrA4mh7OJw08mktPRaOy8CetSHYinC/MI1w931uasdkMloqdyZI8w";
window.siteId = 1;
window.cmsTempletsVer = "1.2";
</script>
<div id="footer">
	<ul id="nav-bottom" class="clearfix">
		<li><a href="/view/267.html" target="_blank">联系方式</a></li>
		<li><a href="/view/212.html" target="_blank">购买教程（带答疑）</a></li>
		<li><a href="/sitemap/" target="_blank">最近更新</a></li>
	</ul>
</div>

<script src="/templets/default/script/jquery1.12.4.min.js"></script>
<script src="/templets/default/script/jquery.snippet.js"></script>
<script src="/templets/default/script/common.js?v=1.2"></script>

<span style="display:none;"><script src="https://s22.cnzz.com/z_stat.php?id=1273514649&web_id=1273514649" language="JavaScript"></script></span>
</body>
</html>
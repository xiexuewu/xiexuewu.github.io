<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<meta name="renderer" content="webkit" /> <!-- 让360支持高速渲染模式 -->
<meta http-equiv="pragma" content="no-cache" /> 
<meta http-equiv="Cache-Control" content="no-store, must-revalidate" /> 
<meta http-equiv="expires" content="Wed, 26 Feb 1997 08:21:57 GMT" /> 
<meta http-equiv="expires" content="0" />
<link rel="shortcut icon" href="/favicon.ico?v=1.2" />
<link href="/templets/default/style/common.css?v=1.2" rel="stylesheet" />
<title>C语言动态内存分配</title>
<meta name="keywords" content="语言,动态,内存,分配,在,进程,的,地址,空," />
<meta name="description" content="在进程的地址空间中，代码区、常量区、全局数据区的内存在程序启动时就已经分配好了，它们大小固定，不能由程序员分配和释放，只能等到程序运行结束由操作系统回收。 这称为静" />
</head>
<body>
<div id="header" class="clearfix">
	<a id="logo" class="left" href="/">
		<img height="26" src="/templets/default/images/logo_monkey.png" alt="数据结构与算法教程Logo" />
	</a>
	<ul id="nav-main" class="hover-none left clearfix">
		<li><a href="/">教程首页</a></li>
		<li><a href="/view/212.html">购买教程</a></li>
		<!--<li><a href="/c/">辅导班</a></li>-->
	</ul>
	<span id="sidebar-toggle" class="toggle-btn" toggle-target="#sidebar">目录 <span class="glyphicon"></span></span>
</div>
<!--qq交流群
<div id="header" class="clearfix">
	<ul id="nav-main" class="hover-none left clearfix">
		<li><a style="padding-left:10px" href="/uploads/allimg/240128/2-24012R01153206.jpg" target="_blank">QQ交流群：937184979</a></li>
	</ul>
</div>-->
<div id="main" class="clearfix">
	<div id="sidebar" class="toggle-target">
	<div id="contents">
		<dt><span class="glyphicon glyphicon-option-vertical" aria-hidden="true"></span>教程目录</dt>
		
			<dd>
				<span class="channel-num">1</span>
				<a href='/c/base/'>编程基础</a>
			</dd>
		
			<dd>
				<span class="channel-num">2</span>
				<a href='/c/begin/'>C语言初探</a>
			</dd>
		
			<dd>
				<span class="channel-num">3</span>
				<a href='/c/variable_datatype/'>变量和数据类型</a>
			</dd>
		
			<dd>
				<span class="channel-num">4</span>
				<a href='/c/io/'>C语言输入输出</a>
			</dd>
		
			<dd>
				<span class="channel-num">5</span>
				<a href='/c/branch_loop/'>循环结构和选择结构</a>
			</dd>
		
			<dd>
				<span class="channel-num">6</span>
				<a href='/c/array/'>C语言数组</a>
			</dd>
		
			<dd>
				<span class="channel-num">7</span>
				<a href='/c/function/'>C语言函数</a>
			</dd>
		
			<dd>
				<span class="channel-num">8</span>
				<a href='/c/preprocess/'>预处理命令</a>
			</dd>
		
			<dd>
				<span class="channel-num">9</span>
				<a href='/c/pointer/'>指针</a>
			</dd>
		
			<dd>
				<span class="channel-num">10</span>
				<a href='/c/struct/'>结构体</a>
			</dd>
		
			<dd>
				<span class="channel-num">11</span>
				<a href='/c/file/'>文件操作</a>
			</dd>
		
			<dd>
				<span class="channel-num">12</span>
				<a href='/c/debug/'>C语言调试</a>
			</dd>
		<dd class="this"> <span class="channel-num">13</span> <a href="/c/memory/">C语言内存精讲</a> </dd><dl class="dl-sub"><dd>13.1 <a href="/view/566.html">一个程序在计算机中到底是如何运行的？</a></dd><dd>13.2 <a href="/view/567.html">虚拟内存到底是什么？为什么我们在C语言中看到的地址是假的？</a></dd><dd>13.3 <a href="/view/568.html">虚拟地址空间以及编译模式</a></dd><dd>13.4 <a href="/view/569.html">C语言内存对齐，提高寻址效率</a></dd><dd>13.5 <a href="/view/570.html">内存分页机制，完成虚拟地址的映射</a></dd><dd>13.6 <a href="/view/571.html">分页机制究竟是如何实现的？</a></dd><dd>13.7 <a href="/view/572.html">MMU部件以及对内存权限的控制</a></dd><dd>13.8 <a href="/view/573.html">Linux下C语言程序的内存布局</a></dd><dd>13.9 <a href="/view/574.html">Windows下C语言程序的内存布局</a></dd><dd>13.10 <a href="/view/575.html">用户模式和内核模式</a></dd><dd>13.11 <a href="/view/576.html">栈（Stack）是什么？栈溢出又是怎么回事？</a></dd><dd>13.12 <a href="/view/577.html">一个函数在栈上到底是怎样的？</a></dd><dd>13.13 <a href="/view/578.html">函数调用惯例(Calling Convention)</a></dd><dd>13.14 <a href="/view/579.html">用一个实例来深入剖析函数进栈出栈的过程</a></dd><dd>13.15 <a href="/view/580.html">栈溢出攻击的原理是什么？</a></dd><dd>13.16 <a href="/view/581.html">C语言动态内存分配</a></dd><dd>13.17 <a href="/view/582.html">malloc函数背后的实现原理——内存池</a></dd><dd>13.18 <a href="/view/583.html">C语言野指针以及非法内存操作</a></dd><dd>13.19 <a href="/view/584.html">C语言内存泄露（内存丢失）</a></dd><dd>13.20 <a href="/view/585.html">C语言变量的存储类别和生存期</a></dd></dl>
			<dd>
				<span class="channel-num">14</span>
				<a href='/c/module/'>多文件编程</a>
			</dd>
		
			<dd>
				<span class="channel-num">15</span>
				<a href='/c/practice/'>C语言项目实战案例</a>
			</dd>
		
	</div>
</div>
	<div id="article-wrap">
		<div id="article">
			<h1>C语言动态内存分配</h1>
			<div class="pre-next-page pre-next-detail clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="/view/580.html">栈溢出攻击的原理是什么？</a></span>
                    <span class="next right"><a href="/view/582.html">malloc函数背后的实现原理——内存池</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <div class="pre-next-page pre-next-brief clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="#">上一节</a></span>
                    <span class="next right"><a href="#">下一节</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <script type="text/javascript">window.prePageURL = "/view/580.html";window.nextPageURL = "/view/582.html";</script>
			<div id="arc-body">在进程的地址空间中，代码区、常量区、全局数据区的内存在程序启动时就已经分配好了，它们大小固定，不能由程序员分配和释放，只能等到程序运行结束由操作系统回收。<span style="color: #b22222">这称为静态内存分配。</span><br />
<br />
<u><a href='/view/169.html' target='_blank'>栈</a></u>区和堆区的内存在程序运行期间可以根据实际需求来分配和释放，不用在程序刚启动时就备足所有内存。<span style="color: #b22222">这称为动态内存分配。</span><br />
<br />
使用静态内存的优点是速度快，省去了向操作系统申请内存的时间，缺点就是不灵活，缺乏表现力，例如不能控制数据的作用范围，不能使用较大的内存。而使用动态内存可以让程序对内存的管理更加灵活和高效，需要内存就立即分配，而且需要多少就分配多少，从几个字节到几个GB不等；不需要时就立即回收，再分配给其他程序使用。
<h2>
	栈和堆的区别</h2>
栈区和堆区的管理模式有所不同：栈区内存由系统分配和释放，不受程序员控制；堆区内存完全由程序员掌控，想分配多少就分配多少，想什么时候释放就什么时候释放，非常灵活。<br />
<br />
程序启动时会为栈区分配一块大小适当的内存，对于一般的函数调用这已经足够了，函数进栈出栈只是 ebp、esp 寄存器指向的变换，或者是向已有的内存中写入数据，不涉及内存的分配和释放。当函数中有较大的局部<u><a href='/view/181.html' target='_blank'>数组</a></u>时，比如 1024*10 个元素，编译器就会在函数代码中插入针对栈的动态内存分配函数，这样函数被调用时才分配内存，不调用就不分配。<br />
<br />
我们经常听说&ldquo;栈内存的分配效率要高于堆&rdquo;就是这个道理，因为大部分情况下并没有真的分配栈内存，仅仅是对已有内存的操作。<br />
<h2>
	动态内存分配函数</h2>
<span style="color: #008000">堆（Heap）</span>是唯一由程序员控制的内存区域，我们常说的动态内存分配也是在这个区域。在堆上分配和释放内存需要用到C语言标准库中的几个函数：malloc()、calloc()、realloc() 和 free()。<br />
<br />
这几个函数的具体用法在<a href="https://legacy.cplusplus.com/reference/clibrary/" target="_blank">C标准库</a>中已经进行了讲解，这里不再赘述，仅作简单的对比，并给出一个综合示例。
<h4>
	1) malloc()</h4>
原型：void* malloc (size_t size);<br />
<br />
作用：在堆区分配 size 字节的内存空间。<br />
<br />
返回值：成功返回分配的内存地址，失败则返回NULL。<br />
<br />
注意：分配内存在动态存储区（堆区），手动分配，手动释放，申请时空间可能有也可能没有，需要自行判断，由于返回的是void*，建议手动强制类型转换。
<h4>
	2) calloc()</h4>
原型：void* calloc(size_t n, size_t size);<br />
<br />
功能：在堆区分配 n*size 字节的连续空间。<br />
<br />
返回值：成功返回分配的内存地址，失败则返回NULL。<br />
<br />
注意：calloc() 函数是对 malloc() 函数的简单封装，参数不同，使用时务必小心，第一参数是第二参数的单元个数，第二参数是单位的字节数。
<h4>
	3) realloc()</h4>
原型：void* realloc(void *ptr, size_t size);<br />
<br />
功能：对 ptr 指向的内存重新分配 size 大小的空间，size 可比原来的大或者小，还可以不变（如果你无聊的话）。<br />
<br />
返回值：成功返回更改后的内存地址，失败则返回NULL。
<h4>
	4) free()</h4>
原型：void free(void* ptr);<br />
<br />
功能：释放由 malloc()、calloc()、realloc() 申请的内存空间。
<h4>
	几点注意</h4>
1) 每个内存分配函数必须有相应的 free 函数，释放后不能再次使用被释放的内存。<br />
<br />
2) 在分配内存时最好不要直接用数字指定内存空间的大小，这样不利于程序的移植。因为在不同的操作系统中，同一数据类型的长度可能不一样。为了解决这个问题，C语言提供了一个判断数据类型长度的操作符，就是 sizeof。<br />
<br />
3) free(p) 并不能改变指针 p 的值，p 依然指向以前的内存，为了防止再次使用该内存，建议将 p 的值手动置为 NULL。<br />
<br />
sizeof 是一个单目操作符，不是函数，用以获取数据类型的长度时必须加括号，例如 sizeof(int)、sizeof(char) 等。<br />
<br />
最后是一个综合的示例：
<pre class="c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define  N  (5)
#define  N1 (7)
#define  N2 (3)

int main()
{
    int *ip;
    int *large_ip;
    int *small_ip;
    if((ip = (int*)malloc(N * sizeof(int))) == NULL)
    {
        printf(&quot;memory allocated failed!\n&quot;);
        exit(1);
    }
    int i;
    for(i = 0; i &lt; N; i++)
    {
        ip[i] = i;
        printf(&quot;ip[%d] = %d\t&quot;, i, ip[i]);
    }
    printf(&quot;\n&quot;);

    if((large_ip = (int* )realloc(ip, N1 * sizeof(int))) == NULL)
    {
        printf(&quot;memory allocated failed!\n&quot;);
        exit(1);
    }
    for(i = N; i &lt; N1; i++)
        large_ip[i] = 9;
    for(i = 0; i &lt; N1; i++)
        printf(&quot;large_ip[%d] = %d\t&quot;, i, large_ip[i]);
    printf(&quot;\n&quot;);

    if((small_ip = (int*)realloc(large_ip, N2 * sizeof(int))) == NULL)
    {
        printf(&quot;memory allocated failed!\n&quot;);
        exit(1);
    }
    for(i = 0; i &lt; N2; i++)
        printf(&quot;small_ip[%d] = %d\t&quot;, i, small_ip[i]);
    printf(&quot;\n&quot;);

    free(small_ip);
    small_ip = NULL;

    system(&quot;pause&quot;);
    return 0;
}</pre>
运行结果：<br />
ip[0] = 0 &nbsp; &nbsp;ip[1] = 1 &nbsp; &nbsp;ip[2] = 2 &nbsp; &nbsp;ip[3] = 3 &nbsp; &nbsp;ip[4] = 4<br />
large_ip[0] = 0 &nbsp; &nbsp;large_ip[1] = 1 &nbsp; &nbsp;large_ip[2] = 2 &nbsp; &nbsp;large_ip[3] = 3 &nbsp; &nbsp;large_ip[4] = 4 &nbsp; &nbsp;large_ip[5] = 9 &nbsp; &nbsp;large_ip[6] = 9<br />
small_ip[0] = 0 &nbsp; &nbsp;small_ip[1] = 1 &nbsp; &nbsp;small_ip[2] = 2<br />
<br />
代码说明：<br />
1) 代码看似很长，其实较为简单，首先分配一个包含 5 个整型的内存区域，分别赋值 0 到 4；再用 realloc 函数扩大内存区域以容纳 7 个整型数，对额外的两个整数赋值为 9；最后再用 realloc 函数缩小内存区域，直接输出结果（因为 realloc 函数会自动复制数据）。<br />
<br />
2)&nbsp;这次把分配函数与验证返回值验证写在了一起，为的是书写方便，考虑到优先级问题添加了适当的括号，这种写法较为常用，注意学习使用。<br />
<br />
3) 本例 free 函数只用释放 small_ip 指针即可，如函数介绍中注意里提到的，另外两个指针已被系统回收，不能再次使用。 </div>
			<div class="pre-next-page pre-next-detail clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="/view/580.html">栈溢出攻击的原理是什么？</a></span>
                    <span class="next right"><a href="/view/582.html">malloc函数背后的实现原理——内存池</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <div class="pre-next-page pre-next-brief clearfix">
                    <span class="pre left"><span class="glyphicon glyphicon-menu-left"></span> <a href="#">上一节</a></span>
                    <span class="next right"><a href="#">下一节</a> <span class="glyphicon glyphicon-menu-right"></span></span>
                </div>
                <script type="text/javascript">window.prePageURL = "/view/580.html";window.nextPageURL = "/view/582.html";</script>
		</div>
		
	</div>
</div>
<div id="addweixin-widget" class="clearfix">
	<div class="box">
		<p>
			<a href="/uploads/allimg/240115/2-240115210631414.png" target="_blank"><img src="/uploads/allimg/240115/2-240115210631414.png" alt="添加微信咨询" title="点击查看大图"></a>
			<span class="pc-tip">添加管理员微信<br/>免费领视频教程</span>
			<span class="wap-tip">加管理员微信免费领视频教程<br>微信ID：xiexuewu333</span>
		</p>
		<span id="close-addweixin-widget" class="glyphicon glyphicon-remove-circle"></span>
	</div>
</div>
<script type="text/javascript">
// 当前文章ID
window.arcIdRaw = 'a_' + 581;
window.arcId = "0f39M1TnuMz144oewzrtFNc2+1qPdQtNM6uJvCnrzQhPK9TuV3IEzqFcyw";
window.siteId = 1;
window.cmsTempletsVer = "1.2";
</script>
<div id="footer">
	<ul id="nav-bottom" class="clearfix">
		<li><a href="/view/267.html" target="_blank">联系方式</a></li>
		<li><a href="/view/212.html" target="_blank">购买教程（带答疑）</a></li>
		<li><a href="/sitemap/" target="_blank">最近更新</a></li>
	</ul>
</div>

<script src="/templets/default/script/jquery1.12.4.min.js"></script>
<script src="/templets/default/script/jquery.snippet.js"></script>
<script src="/templets/default/script/common.js?v=1.2"></script>

<span style="display:none;"><script src="https://s22.cnzz.com/z_stat.php?id=1273514649&web_id=1273514649" language="JavaScript"></script></span>
</body>
</html>